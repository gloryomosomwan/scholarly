# Documentation

## Table of Contents
- [Documentation](#documentation)
  - [How to run the app](#how-to-run-the-app)
  - [Recurring Events](#recurring-events)
    - [Definitions](#definitions)
    - [`rrule` and `datetime()`](#rrule-and-datetime)
    - [Lookbacks](#lookbacks)
    - [Recurrence utility functions](#recurrence-utility-functions)
    - [Setting Recurrences](#setting-recurrences)
    - [Boundaries](#boundaries)
  - [Agenda Calendar](#agenda-calendar)
    - [Implementation](#implementation)
    - [Interpolation and positioning](#interpolation-and-positioning)
  - [Event Types](#event-types)
    - [All-day](#all-day)
    - [Crossover](#crossover)
    - [Multi-day](#multi-day)
    - [Regular](#regular)
  - [Managing data types](#managing-data-types)
  - [`useLiveQuery()`](#uselivequery)
  - [Data Flow and Memoization for Asynchronous Form Data](#data-flow-and-memoization-for-asynchronous-form-data)
    - [The Chain of Interaction](#the-chain-of-interaction)
  - [Display quirks](#display-quirks)
  - [Dates vs. Days](#dates-vs-days)
  - [Database management](#database-management)
    - [Changing schemas](#changing-schemas)
  - [How `refresh()` works in dashboard components](#how-refresh-works-in-dashboard-components)
  - [How Events and Tests are differentiated](#how-events-and-tests-are-differentiated)
  - [Comment annotations](#comment-annotations)
  - [How to run tests](#how-to-run-tests)
  - [Other things to keep in mind](#other-things-to-keep-in-mind)

## How to run the app

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

3. ???

4. Profit

## Recurring Events

### Definitions
- **Recurrence, recurrence string**: An `RRule` string that defines how an Event recurs

   >`DTSTART:20251023T200000Z RRULE:INTERVAL=1;FREQ=MONTHLY`

- **Recurring event**: An Event that has a recurrence string/recurrence
- **Non-recurring event**: An Event that doesn't have a recurrence string/recurrence
- **Recurrence event**: An Event that is generated by a recurrence string
- **Occurrence**: A happening of an Event, this will generally be represented as a `Date` object that corresponds to the start of the Event

### `rrule` and `datetime()`

The `rrule` and its associated `datetime()` utility function have a few tricky bits. Here are some things to keep in mind:

1. The DTSTART portion of the recurrence string produced by `rrule` is actually displaying a date in local time, even though it ends with a Z, characteristic of a date in UTC time:

   > The `dtstart` of the following string: `DTSTART:20251023T200000Z RRULE:INTERVAL=1;FREQ=MONTHLY` is actually October 23rd, 2025 at 8 p.m. local time, not UTC.

2. The UTC components on the `Date` object returned by `datetime()` are also in local time:

   ```typescript
   const dt = datetime(2025, 9, 18, 13);
   const d = new Date(2025, 8, 18, 13);

   console.log(dt.getUTCHours());
   // 13

   console.log(d.getUTCHours());
   // 19
   ``` 

3. When creating a `Date` using `datetime()`, the month is 1-based:

   (WIP)

4. `datetime()` returns a regular `Date` object

5. An occurrence will take place on the `until` of a recurrence but not after

6. When generating occurrences based on `dtstart`, the occurrences that are generated will use `dtstart` as the base date and base time

### Lookbacks

A lookback is a way to check if an occurrence has started before the beginning of the date currently being looked at. 

For example, if an occurrence has a duration of 3 hours, then the lookback would be set to 9 p.m. of the previous day. Then, we would search for occurrences between 9 p.m. of the previous day and midnight of the current day. We wouldn't have to search earlier than this because if the 3-hour occurrence had started at 8:59 p.m. then it would have ended before the current day and we wouldn't have to worry about it.

### Recurrence utility functions 

#### `getEventOccurrencesByDay()`

This function calculates all occurrences that take place on a given day in any capacity, and returns an array of these occurrences. This includes:

- Occurrences that start and end on the day
- Occurrences that start **before** the day starts but end on the day
- Occurrences that start on the day and end **after** day ends
- Occurrences that start **before** the day and end **after** the day

This is to account for the all possible Event types (e.g. crossover, multi-day).

#### `getRecurrenceEventsByDay()`

This function takes in an array of recurring Events, and returns the Event representations (recurrence events) of all the occurrences that take place on the given day. Turning these occurrences into Events here means less work to do elsewhere in the code.

For example, lets say someone had had basketball practice every Friday from 6 p.m. to 8 p.m., starting on October 24th. That event would look like this:

```typescript
{
   // ... other properties
   "name": "Basketball practice",
   "startDate": "2025-10-25T00:00:00.000Z", 
   "endDate": "2025-10-25T02:00:00.000Z",
   "recurring": "DTSTART:20251024T180000Z RRULE:INTERVAL=1;FREQ=WEEKLY;UNTIL=20251031T180000Z;BYDAY=FR"
}
```
If were looking at the agenda for October 31st (the following Friday), `useEventsByDay()` would pass this event to `getRecurrenceEventsByDay()`, along with all other events retrieved from the database with recurrence strings.

For each recurring event, it would check if the event had an occurence on October 31st. For our basketball practice, the occurrence would be a `Date` set to 6 p.m. on October 31st:

```typescript
console.log(occurrences)
// [2025-10-31T18:00:00.000Z]
```

> Note: Remember that `datetime()` dates aren't actually in UTC

Then it would take this occurrence and create an Event from it. In this particular scenario, the event would look like this:

```typescript
{
   // ... other properties
   "name": "Basketball practice",
   "startDate": "2025-11-01T00:00:00.000Z", 
   "endDate": "2025-11-01T02:00:00.000Z",
   "recurring": "DTSTART:20251024T180000Z RRULE:INTERVAL=1;FREQ=WEEKLY;UNTIL=20251031T180000Z;BYDAY=FR"
}
```

Notice that the only difference is the start and end dates.

The function then returns this event (and any others it found) in an array.

#### `passJSDateToDatetime()`

The `datetime()` helper function from `rrule` takes in local time components as arguments. This function helps convert a built-in JavaScript `Date` into one that will work with the `rrule` methods.

#### `convertRRuleOccurrenceToJSDate()`

Similar to `passJSDateToDatetime()` but the other way around.

#### `getActiveRecurrenceEvents()`

Similar to `getRecurrenceEventsByDay()` but only returns events that are currently taking place. 

#### `getOccurrencesThatTakePlaceBetweenLookbackAndRightNow()`

Similar to `getEventOccurrencesByDay()` but only looks back from the current moment.

#### `getEventOccurrencesBetweenDays()`

Similar to `getEventOccurrencesByDay()` but starts its search at midnight of a given day and ends it at the end of another.

### Setting Recurrences

The way recurrences are handled is that each event can have a recurrence string. Inside `event-form`, that string is represented as a state variable, and any recurrence component that wants to update the string has to create a brand new recurrence rule, and set that rule's string as the new recurrence string for the `Event`.

### Boundaries
(WIP)

## Agenda Calendar 

### Implementation

### Interpolation and positioning 

#### Important values

**`Day` height**: The height of a `Day` is 47. We can use this to calculate how much the agenda would have to vertically translate by to have the last week of the month sitting right under the header, which is where the first week initially is. This would give us a range.

The agenda has to travel the height of 5 `Days` to do this, which gives us 47 x 5, or 235.

**Header height**: The height of the calendar header is 52

In order to get the `MonthPager` to move when the agenda is dragged up, we use interpolation. This is the relevant code:

```typescript
translateY: interpolate(
   bottomSheetTranslationY.value,
   [calendarBottom.value, calendarBottom.value - 235],
   [0, (paddingTop + 52) - selectedDatePosition.value],
   Extrapolate.CLAMP
)
```

Of note are the second and third arguments. The second argument is the input range, this means that the `bottomSheetTranslationY` value can be expected to only range from `calendarBottom` to `calendarBottom` - 235. The third argument is a bit trickier.

The third argument is the output range, or, what we want the range of the `Month`'s Y translation value to be. In theory, we want it to go from its normal position (0) to whatever Y value will set the week of currently selected date to be right under the header, which is where the 1st week of the month usually is.

## Event Types

### All-day

Events that last exactly 24 hours and take place from midnight of one day to midnight of the next day.

> An Event that starts at midnight on October 23rd and ends at midnight on October 24th

### Crossover

Events that last less than 24 hours but span two days.

> An Event that starts at 11 p.m. on October 23rd and ends at 4 a.m. on October 24th

### Multi-day

Events that last longer than 24 hours **or** events that last exactly 24 hours but span multiple days.

> An Event that starts at 8 p.m. on October 23rd and ends at 4 p.m. on October 25th

> An Event that starts at 8 p.m. on October 23rd and ends at 8 p.m. on October 24th

### Regular

Events that last less than 24 hours and only take place on one day.

> An Event that starts at 8 p.m. on October 23rd and ends at 11 p.m. on October 23rd

## Managing data types

Each data type (e.g. Semester, Course) has the following things associated with it:

1. A type in `types/index.ts` for usage in the codebase
2. An SQL statement for its respective table and initial seed data `seed.sql`
3. An SQL statement for table creation on app initialization in `db/init.ts`
4. A schema in `db/schema.ts` for `drizzle-orm`
5. A raw data type in `types/drizzle.ts` to use when handling raw data
6. A conversion function in `utils/conversion.ts` to convert raw data from the database to a version usable in the codebase
7. Hooks in `hooks/useDatabase.ts`
8. A `zod` type in `db/drizzle-zod.ts` for schema validation
9. A form for creation, editing, and deletion

## `useLiveQuery()`

This component acts like a subscription to the database, as any changes to the data the query returns will cause consuming components to rerender.

The first thing returned is an empty array, and it will return the actual data second. This means components that consume this hook will likely render at least twice.

Without a dependency array as the second argument, it won't update the query if the parameters change:

```typescript
export function useAssignmentsByDay(date: Date) {
const { data } = useLiveQuery(db.select().from(assignments).where(
   and(
      gte(assignments.due, startOfDay(date).toISOString()),
      lte(assignments.due, endOfDay(date).toISOString())
   )
)) // No dependency array, will not update the query if date changes ðŸ™…â€â™‚ï¸
const assignmentData = data.map(convertRawAssignment)
return assignmentData
}
```

```typescript
export function useAssignmentsByDay(date: Date) {
const { data } = useLiveQuery(db.select().from(assignments).where(
   and(
      gte(assignments.due, startOfDay(date).toISOString()),
      lte(assignments.due, endOfDay(date).toISOString())
   )
), [date]) // Will update the query if date changes ðŸ‘
const assignmentData = data.map(convertRawAssignment)
return assignmentData
}
```

## Data Flow and Memoization for Asynchronous Form Data

A common challenge in this application is correctly populating a form (e.g., `event-form.tsx`) with data that is loaded asynchronously from the database. This requires handling an initial loading state and updating the form's state when the data arrives, without causing an infinite re-render loop. The interaction between `useLiveQuery`, `useEventById`, `useMemo`, and the form component is a key pattern to understand.

### The Chain of Interaction

1.  **`useLiveQuery` (The Source):** This hook from `drizzle-orm/expo-sqlite` is the foundation. It fetches data from the database.
    *   **Behavior:** On its first run, it returns an empty array (`[]`) and starts the database query in the background. When the query completes, `useLiveQuery` receives the data and triggers a re-render in the component that called it.
    *   **Referential Stability:** Crucially, `useLiveQuery` returns a stable object reference. The `data` object it returns is only a *new* object if the underlying database results have actually changed. On re-renders where the data is the same, it returns the *exact same object reference* as the previous render.

2.  **`useEventById` (The Processor):** This custom hook consumes `useLiveQuery` and processes its data.
    *   It calls `convertRawEvent` to transform the raw database row into a usable JavaScript object, notably converting date strings into `Date` objects.

3.  **The Problem (The Infinite Loop):** The `convertRawEvent` function always creates a *new* object with *new `Date` instances* every time it runs. Before the fix, `useEventById` would call this function on every render. This meant that `eventData` in `EventForm` was a new object on every render.

    This causes an infinite loop if used in a `useEffect` dependency array:
    *   `useEffect` sees a "new" `eventData` object and runs.
    *   The effect updates the form's state (`setName`, `setStartDate`, etc.).
    *   Updating state causes a re-render.
    *   The re-render creates another *new* `eventData` object.
    *   The cycle repeats.

4.  **The Solution (`useMemo`):** We break the cycle by wrapping the data processing in `useMemo` inside the `useEventById` hook.

    ```typescript
    // in hooks/useDatabase.ts
    export function useEventById(id: number | null) {
      const { data } = useLiveQuery(...);

      return useMemo(() => {
        if (!data || data.length === 0) return null;
        const event = convertRawEvent(data[0]);
        return event;
      }, [data]); // The dependency array is key!
    }
    ```

    *   `useMemo` acts as a cache. It only re-runs the code inside it if a dependency in its array (`[data]`) has changed.
    *   Because `useLiveQuery` provides a stable `data` reference (from step 1), `useMemo`'s dependency check works perfectly. On re-renders where the database data is the same, `data` is the same object reference, so `useMemo` skips its function and returns the previously cached `event` object.
    *   This provides a **stable, memoized `eventData` object** to the form component.

5.  **`EventForm.tsx` (The Consumer):** The form can now safely use this stable data in a `useEffect`.

    ```typescript
    // in app/event-form.tsx
    const eventData = id ? useEventById(convertedID) : null;

    useEffect(() => {
      if (eventData) {
        // ...set form state (setName, setStartDate, etc.)
      }
    }, [eventData]);
    ```

    *   **First Render:** `eventData` is `null`. The effect does nothing.
    *   **Second Render (Data Arrives):** `useEventById` returns the new, populated, memoized `eventData` object. The `useEffect` sees the dependency has changed (from `null` to an object) and runs once, populating the form.
    *   **Subsequent Renders:** On further re-renders (e.g., from user input), `useEventById` returns the *same cached `eventData` object*. The `useEffect` sees no change in its dependency and does not run again, breaking the infinite loop.

## Display quirks 

- `DateTimePicker` needs to be within a `View` to consistently display in inline mode

- On the course page, the `MaterialTopTabs` component doesn't cover the bottom of the screen, but this is hidden by the tab bar

## Dates vs. Days

A **date** generally refers to a specific moment in time or instant, and is usually represented by the number of milliseconds since the UNIX epoch.

A **day** generally refers to a day (e.g. October 24th), and is usually represented by a `Date` set to midnight of that day.

## Database management

The database can be switched by changing `openDatabaseSync`'s `databaseName` in `db/init.ts`:

```typescript
export const sqlite = openDatabaseSync('myDatabase', { enableChangeListener: true })
```

And changing the `SQLiteProvider`'s `databaseName` in `app/layout.tsx`:

```typescript
      <SQLiteProvider databaseName="myDatabase">
```

Databases can also be deleted from simulators by deleting their respective .sqlite files in a directory.

To find out the data directory for the currently running simulator run the following command:

```bash
xcrun simctl get_app_container booted <bundle-identifier> data
```

Replace `<bundle-identifier>` with your app's **bundle ID** (e.g., `com.yourapp.name`).

This should print out a path where data for the currently booted simulator can be found. Navigate to that directory and then navigate to the **SQLite** directory:

```bash
cd Documents/SQLite
```

The database files will be located there.

### Changing schemas

When changing schemas make sure to update both `db/init.ts` and `db/seed.sql`

## How `refresh()` works in dashboard components

## How Events and Tests are differentiated

Events and Tests are differentiated by adding a `type` property to Tests as they are retrieved from the database. Their type property is set to `test`, so that both Events and Tests have a type property. Then, in the code we can run conditional logic based on the value of that `type` property. If it is `general`, `lecture`, or some other course related type, we know it's an Event. If it is `test`, we know it is a Test.

## Comment annotations

**CHECK**: Double-check this code

**TODO**: This still needs to be done

## How to run tests

Maestro is used for end-to-end testing


## Other things to keep in mind

- Both the Agenda and Up Next section use the `useEventsByDay()` hook 
- `calendarBottom` is not being set by the `Month`, it's just assumed to be 235
