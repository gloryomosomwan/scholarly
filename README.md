# Documentation

## Table of Contents
- [Documentation](#documentation)
  - [How to run the app](#how-to-run-the-app)
  - [Recurring Events](#recurring-events)
    - [Definitions](#definitions)
    - [`rrule` and `datetime()`](#rrule-and-datetime)
    - [Lookbacks](#lookbacks)
    - [Recurrence utility functions](#recurrence-utility-functions)
    - [Boundaries](#boundaries)
  - [Agenda Calendar](#agenda-calendar)
    - [Implementation](#implementation)
    - [Interpolation and positioning](#interpolation-and-positioning)
  - [Event Types](#event-types)
    - [All-day](#all-day)
    - [Crossover](#crossover)
    - [Multi-day](#multi-day)
    - [Regular](#regular)
  - [Managing data types](#managing-data-types)
  - [`useLiveQuery()`](#uselivequery)
  - [Display quirks](#display-quirks)
  - [Dates vs. Days](#dates-vs-days)
  - [Database management](#database-management)
  - [How `refresh()` works in dashboard components](#how-refresh-works-in-dashboard-components)
  - [How Events and Tests are differentiated](#how-events-and-tests-are-differentiated)
  - [Comment annotations](#comment-annotations)
  - [How to run tests](#how-to-run-tests)
  - [Other things to keep in mind](#other-things-to-keep-in-mind)

## How to run the app

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

3. ???

4. Profit

## Recurring Events

### Definitions
- **Recurrence, recurrence string**: An `RRule` string that defines how an Event recurs

   >`DTSTART:20251023T200000Z RRULE:INTERVAL=1;FREQ=MONTHLY`

- **Recurring event**: An Event that has a recurrence string/recurrence
- **Non-recurring event**: An Event that doesn't have a recurrence string/recurrence
- **Recurrence event**: An Event that is generated by a recurrence string
- **Occurrence**: A happening of an Event, this will generally be represented as a `Date` object that corresponds to the start of the Event

### `rrule` and `datetime()`

The `rrule` and its associated `datetime()` utility function have a few tricky bits. Here are some things to keep in mind:

1. The DTSTART portion of the recurrence string produced by `rrule` is actually displaying a date in local time, even though it ends with a Z, characteristic of a date in UTC time:

   > The `dtstart` of the following string: `DTSTART:20251023T200000Z RRULE:INTERVAL=1;FREQ=MONTHLY` is actually October 23rd, 2025 at 8 p.m. local time, not UTC.

2. The UTC components on the `Date` object returned by `datetime()` are also in local time:

   ```typescript
   const dt = datetime(2025, 9, 18, 13);
   const d = new Date(2025, 8, 18, 13);

   console.log(dt.getUTCHours());
   // 13

   console.log(d.getUTCHours());
   // 19
   ``` 

3. When creating a `Date` using `datetime()`, the month is 1-based:

   (WIP)

4. `datetime()` returns a regular `Date` object

5. An occurrence will take place on the `until` of a recurrence but not after

6. When generating occurrences based on `dtstart`, the occurrences that are generated will use `dtstart` as the base date and base time

### Lookbacks

A lookback is a way to check if an occurrence has started before the beginning of the date currently being looked at. 

For example, if an occurrence has a duration of 3 hours, then the lookback would be set to 9 p.m. of the previous day. Then, we would search for occurrences between 9 p.m. of the previous day and midnight of the current day. We wouldn't have to search earlier than this because if the 3-hour occurrence had started at 8:59 p.m. then it would have ended before the current day and we wouldn't have to worry about it.

### Recurrence utility functions 

#### `getEventOccurrencesByDay()`

This function calculates all occurrences that take place on a given day in any capacity, and returns an array of these occurrences. This includes:

- Occurrences that start and end on the day
- Occurrences that start **before** the day starts but end on the day
- Occurrences that start on the day and end **after** day ends
- Occurrences that start **before** the day and end **after** the day

This is to account for the all possible Event types (e.g. crossover, multi-day).

#### `getRecurrenceEventsByDay()`

This function takes in an array of recurring Events, and returns the Event representations (recurrence events) of all the occurrences that take place on the given day. Turning these occurrences into Events here means less work to do elsewhere in the code.

For example, lets say someone had had basketball practice every Friday from 6 p.m. to 8 p.m., starting on October 24th. That event would look like this:

```JSON
{
   // ... other properties
   "name": "Basketball practice",
   "startDate": "2025-10-25T00:00:00.000Z", 
   "endDate": "2025-10-25T02:00:00.000Z",
   "recurring": "DTSTART:20251024T180000Z RRULE:INTERVAL=1;FREQ=WEEKLY;UNTIL=20251031T180000Z;BYDAY=FR"
}
```
If were looking at the agenda for October 31st (the following Friday), `useEventsByDay()` would pass this event to `getRecurrenceEventsByDay()`, along with all other events retrieved from the database with recurrence strings.

For each recurring event, it would check if the event had an occurence on October 31st. For our basketball practice, the occurrence would be a `Date` set to 6 p.m. on October 31st:

```typescript
console.log(occurrences)
// [2025-10-31T18:00:00.000Z]
```

> Note: Remember that `datetime()` dates aren't actually in UTC

Then it would take this occurrence and create an Event from it. In this particular scenario, the event would look like this:

```JSON
{
   // ... other properties
   "name": "Basketball practice",
   "startDate": "2025-11-01T00:00:00.000Z", 
   "endDate": "2025-11-01T02:00:00.000Z",
   "recurring": "DTSTART:20251024T180000Z RRULE:INTERVAL=1;FREQ=WEEKLY;UNTIL=20251031T180000Z;BYDAY=FR"
}
```

Notice that the only difference is the start and end dates.

The function then returns this event (and any others it found) in an array.

#### `passJSDateToDatetime()`

The `datetime()` helper function from `rrule` takes in local time components as arguments. This function helps convert a built-in JavaScript `Date` into one that will work with the `rrule` methods.

#### `convertRRuleOccurrenceToJSDate()`

Similar to `passJSDateToDatetime()` but the other way around.

#### `getActiveRecurrenceEvents()`

Similar to `getRecurrenceEventsByDay()` but only returns events that are currently taking place. 

#### `getOccurrencesThatTakePlaceBetweenLookbackAndRightNow()`

Similar to `getEventOccurrencesByDay()` but only looks back from the current moment.

#### `getEventOccurrencesBetweenDays()`

Similar to `getEventOccurrencesByDay()` but starts its search at midnight of a given day and ends it at the end of another.

### Boundaries
(WIP)

## Agenda Calendar 

### Implementation

### Interpolation and positioning 

#### Important values

**`Day` height**: The height of a `Day` is 47. We can use this to calculate how much the agenda would have to vertically translate by to have the last week of the month sitting right under the header, which is where the first week initially is. This would give us a range.

The agenda has to travel the height of 5 `Days` to do this, which gives us 47 x 5, or 235.

**Header height**: The height of the calendar header is 52

In order to get the `MonthPager` to move when the agenda is dragged up, we use interpolation. This is the relevant code:

```typescript
translateY: interpolate(
   bottomSheetTranslationY.value,
   [calendarBottom.value, calendarBottom.value - 235],
   [0, (paddingTop + 52) - selectedDatePosition.value],
   Extrapolate.CLAMP
)
```

Of note are the second and third arguments. The second argument is the input range, this means that the `bottomSheetTranslationY` value can be expected to only range from `calendarBottom` to `calendarBottom` - 235. The third argument is a bit trickier.

The third argument is the output range, or, what we want the range of the `Month`'s Y translation value to be. In theory, we want it to go from its normal position (0) to whatever Y value will set the week of currently selected date to be right under the header, which is where the 1st week of the month usually is.

## Event Types

### All-day

Events that last exactly 24 hours and take place from midnight of one day to midnight of the next day.

> An Event that starts at midnight on October 23rd and ends at midnight on October 24th

### Crossover

Events that last less than 24 hours but span two days.

> An Event that starts at 11 p.m. on October 23rd and ends at 4 a.m. on October 24th

### Multi-day

Events that last longer than 24 hours **or** events that last exactly 24 hours but span multiple days.

> An Event that starts at 8 p.m. on October 23rd and ends at 4 p.m. on October 25th

> An Event that starts at 8 p.m. on October 23rd and ends at 8 p.m. on October 24th

### Regular

Events that last less than 24 hours and only take place on one day.

> An Event that starts at 8 p.m. on October 23rd and ends at 11 p.m. on October 23rd

## Managing data types

Each data type (e.g. Semester, Course) has the following things associated with it:

1. A type in `types/index.ts` for usage in the codebase
2. An SQL statement for its respective table and initial seed data `seed.sql`
3. An SQL statement for table creation on app initialization in `db/init.ts`
4. A schema in `db/schema.ts` for `drizzle-orm`
5. A raw data type in `types/drizzle.ts` to use when handling raw data
6. A conversion function in `utils/conversion.ts` to convert raw data from the database to a version usable in the codebase
7. Hooks in `hooks/useDatabase.ts`
8. A `zod` type in `db/drizzle-zod.ts` for schema validation
9. A form for creation, editing, and deletion

## `useLiveQuery()`

This component acts like a subscription to the database, as any changes to the data the query returns will cause consuming components to rerender.

The first thing returned is an empty array, and it will return the actual data second. This means components that consume this hook will likely render at least twice.

Without a dependency array as the second argument, it won't update the query if the parameters change:

```typescript
export function useAssignmentsByDay(date: Date) {
const { data } = useLiveQuery(db.select().from(assignments).where(
   and(
      gte(assignments.due, startOfDay(date).toISOString()),
      lte(assignments.due, endOfDay(date).toISOString())
   )
)) // No dependency array, will not update the query if date changes üôÖ‚Äç‚ôÇÔ∏è
const assignmentData = data.map(convertRawAssignment)
return assignmentData
}
```

```typescript
export function useAssignmentsByDay(date: Date) {
const { data } = useLiveQuery(db.select().from(assignments).where(
   and(
      gte(assignments.due, startOfDay(date).toISOString()),
      lte(assignments.due, endOfDay(date).toISOString())
   )
), [date]) // Will update the query if date changes üëç
const assignmentData = data.map(convertRawAssignment)
return assignmentData
}
```

## Display quirks 

- `DateTimePicker` needs to be within a `View` to consistently display in inline mode

- On the course page, the `MaterialTopTabs` component doesn't cover the bottom of the screen, but this is hidden by the tab bar

## Dates vs. Days

A **date** generally refers to a specific moment in time or instant, and is usually represented by the number of milliseconds since the UNIX epoch.

A **day** generally refers to a day (e.g. October 24th), and is usually represented by a `Date` set to midnight of that day.

## Database management

The database can be switched by changing the `openDatabaseSync`'s `databaseName` in `db/init.ts`:

```typescript
export const sqlite = openDatabaseSync('myDatabase', { enableChangeListener: true })
```

Databases can also be deleted from simulators by locating deleting their respective .sqlite files in a directory.

To find out the data directory for the currently running simulator run the following command:

```bash
xcrun simctl get_app_container booted <bundle-identifier> data
```

Replace `<bundle-identifier>` with your app's **bundle ID** (e.g., `com.yourapp.name`).

This should print out a path where data for the currently booted simulator can be found. Navigate to that directory and then navigate to the **SQLite** directory:

```bash
cd Documents/SQLite
```

The database files will be located there.

## How `refresh()` works in dashboard components

## How Events and Tests are differentiated

Events and Tests are differentiated by adding a `type` property to Tests as they are retrieved from the database. Their type property is set to `test`, so that both Events and Tests have a type property. Then, in the code we can run conditional logic based on the value of that `type` property. If it is `general`, `lecture`, or some other course related type, we know it's an Event. If it is `test`, we know it is a Test.

## Comment annotations

**CHECK**: Double-check this code

**TODO**: This still needs to be done

## How to run tests

Maestro is used for end-to-end testing

## Other things to keep in mind

- Both the Agenda and Up Next section use the `useEventsByDay()` hook 
- `calendarBottom` is not being set by the `Month`, it's just assumed to be 235